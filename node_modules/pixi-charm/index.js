import Tween from './src/tween'
import PathTween from './src/path-tween'

export const easingFormulas = {
  // Linear
  linear: x => x,

  // Smoothstep
  smoothstep: x => x * x * (3 - 2 * x),
  smoothstepSquared: x => Math.pow((x * x * (3 - 2 * x)), 2),
  smoothstepCubed: x => Math.pow((x * x * (3 - 2 * x)), 3),

  // Acceleration
  acceleration: x => x * x,
  accelerationCubed: x => Math.pow(x * x, 3),

  // Deceleration
  deceleration: x => 1 - Math.pow(1 - x, 2),
  decelerationCubed: x => 1 - Math.pow(1 - x, 3),

  // Sine
  sine: x => Math.sin(x * Math.PI / 2),
  sineSquared: x => Math.pow(Math.sin(x * Math.PI / 2), 2),
  sineCubed: x => Math.pow(Math.sin(x * Math.PI / 2), 2),
  inverseSine: x => 1 - Math.sin((1 - x) * Math.PI / 2),
  inverseSineSquared: x => 1 - Math.pow(Math.sin((1 - x) * Math.PI / 2), 2),
  inverseSineCubed: x => 1 - Math.pow(Math.sin((1 - x) * Math.PI / 2), 3),

  // Spline
  spline (t, p0, p1, p2, p3) {
    return 0.5 * (
      (2 * p1) +
      (-p0 + p2) * t +
      (2 * p0 - 5 * p1 + 4 * p2 - p3) * t * t +
      (-p0 + 3 * p1 - 3 * p2 + p3) * t * t * t
    )
  },

  // Bezier curve
  cubicBezier (t, a, b, c, d) {
    const t2 = t * t
    const t3 = t2 * t
    return a + (-a * 3 + t * (3 * a - a * t)) * t + (3 * b + t * (-6 * b + b * 3 * t)) * t + (c * 3 - c * 3 * t) * t2 + d * t3
  }
}

/**
 * Contains multiple tweens and has some convienence methods for interacting with all the tweens at once.
 *
 * @param {...Array} tweens the tween properties
 */
class MultiTween {
  constructor (...tweens) {
    // Make a new tween for each array
    this.tweens = tweens.map(tweenPropertyArguments => new Tween(...tweenPropertyArguments))

    // Add a counter to keep track of the
    // number of tweens that have completed their actions
    this.completionCounter = 0

    // Add `onComplete` methods to all tweens
    this.tweens.forEach(tween => { tween.onComplete = this.completed.bind(this) })
  }

  /**
   * Updates each of the tweens.
   *
   * @param  {number} deltaTime passed in from a ticker update
   */
  update (deltaTime) {
    this.tweens.forEach(tween => tween.update(deltaTime))
  }

  /**
   * Called each time one of the tweens finishes.
   */
  completed () {
    // Add 1 to the `completionCounter`
    this.completionCounter++

    // If all tweens have finished, call the user-defined `onComplete`
    // method, if it's been assigned. Reset the `completionCounter`
    if (this.completionCounter === this.tweens.length) {
      if (this.onComplete) this.onComplete()
      this.completionCounter = 0
    }
  }

  /**
   * Plays all of the tweens.
   */
  play () {
    this.tweens.forEach(tween => tween.play())
  }

  /**
   * Pauses all of the tweens.
   */
  pause () {
    this.tweens.forEach(tween => tween.pause())
  }
}

/**
 *
 */
export default class Charm {
  static get Tween () {
    return Tween
  }

  static get MultiTween () {
    return MultiTween
  }

  static get PathTween () {
    return PathTween
  }

  static get easingFormulas () {
    return easingFormulas
  }

  constructor (renderingEngine = PIXI, ticker = null) {
    if (!renderingEngine) throw new Error('Please assign a rendering engine in the constructor before using charm.js')

    // Find out which rendering engine is being used (the default is Pixi)
    this.renderer = ''

    // If the `renderingEngine` is Pixi, set up Pixi object aliases
    if (renderingEngine.particles.ParticleContainer && renderingEngine.Sprite) {
      this.renderer = 'pixi'
    }

    if (ticker) ticker.add(this.update, this, PIXI.UPDATE_PRIORITY.HIGH)

    this._tweens = []
  }

  get tweens () {
    return this._tweens
  }

  /**
   * Add `scaleX` and `scaleY` properties to Pixi sprites.
   *
   * @param {PIXI.Sprite} sprite the sprite to add the properties to
   */
  _addScaleProperties (sprite) {
    if (this.renderer === 'pixi') {
      if (!('scaleX' in sprite) && ('scale' in sprite) && ('x' in sprite.scale)) {
        Object.defineProperty(
          sprite,
          'scaleX', {
            get () {
              return sprite.scale.x
            },
            set (value) {
              sprite.scale.x = value
            }
          }
        )
      }
      if (!('scaleY' in sprite) && ('scale' in sprite) && ('y' in sprite.scale)) {
        Object.defineProperty(
          sprite,
          'scaleY', {
            get () {
              return sprite.scale.y
            },
            set (value) {
              sprite.scale.y = value
            }
          }
        )
      }
    }
  }

  /**
   * The low level `tweenProperty` function is used as the foundation for the the higher level tween methods.
   *
   * @param  {PIXI.Sprite}  sprite            [description]
   * @param  {[type]}  property          [description]
   * @param  {[type]}  startValue        [description]
   * @param  {[type]}  endValue          [description]
   * @param  {[type]}  totalFrames       [description]
   * @param  {String}  type              [description]
   * @param  {Boolean} yoyo              [description]
   * @param  {Number}  delayBeforeRepeat [description]
   * @return {[type]}                    [description]
   */
  tweenProperty (
    sprite, // Sprite object
    property, // String property
    startValue, // Tween start value
    endValue, // Tween end value
    totalFrames, // Duration in frames
    type = 'smoothstep', // The easing type
    yoyo = false, // Yoyo?
    delayBeforeRepeat = 0 // Delay in frames before repeating
  ) {
    return this.addTween(new Tween(...arguments))
  }

  // `makeTween` is a general low-level method for making complex tweens
  // out of multiple `tweenProperty` functions. Its one argument,
  // `tweensToAdd` is an array containing multiple `tweenProperty` calls

  makeTween (...tweensToAdd) {
    return this.addTween(new MultiTween(...tweensToAdd))
  }

  /* High level tween methods */

  // 1. Simple tweens

  // `fadeOut`
  fadeOut (sprite, frames = 60) {
    return this.tweenProperty(
      sprite, 'alpha', sprite.alpha, 0, frames, 'sine'
    )
  }

  // `fadeIn`
  fadeIn (sprite, frames = 60) {
    return this.tweenProperty(
      sprite, 'alpha', sprite.alpha, 1, frames, 'sine'
    )
  }

  // `pulse`
  // Fades the sprite in and out at a steady rate.
  // Set the `minAlpha` to something greater than 0 if you
  // don't want the sprite to fade away completely
  pulse (sprite, frames = 60, minAlpha = 0) {
    return this.tweenProperty(
      sprite, 'alpha', sprite.alpha, minAlpha, frames, 'smoothstep', true
    )
  }

  // 2. Complex tweens

  slide (
    sprite, endX, endY,
    frames = 60, type = 'smoothstep', yoyo = false, delayBeforeRepeat = 0
  ) {
    return this.makeTween(
      // Create the x axis tween
      [sprite, 'x', sprite.x, endX, frames, type, yoyo, delayBeforeRepeat],

      // Create the y axis tween
      [sprite, 'y', sprite.y, endY, frames, type, yoyo, delayBeforeRepeat])
  }

  breathe (
    sprite, endScaleX = 0.8, endScaleY = 0.8,
    frames = 60, yoyo = true, delayBeforeRepeat = 0
  ) {
    // Add `scaleX` and `scaleY` properties to Pixi sprites
    this._addScaleProperties(sprite)

    return this.makeTween(
      // Create the scaleX tween
      [
        sprite, 'scaleX', sprite.scaleX, endScaleX,
        frames, 'smoothstepSquared', yoyo, delayBeforeRepeat
      ],

      // Create the scaleY tween
      [
        sprite, 'scaleY', sprite.scaleY, endScaleY,
        frames, 'smoothstepSquared', yoyo, delayBeforeRepeat
      ]
    )
  }

  scale (sprite, endScaleX = 0.5, endScaleY = 0.5, frames = 60) {
    // Add `scaleX` and `scaleY` properties to Pixi sprites
    this._addScaleProperties(sprite)

    return this.makeTween(
      // Create the scaleX tween
      [
        sprite, 'scaleX', sprite.scaleX, endScaleX,
        frames, 'smoothstep', false
      ],

      // Create the scaleY tween
      [
        sprite, 'scaleY', sprite.scaleY, endScaleY,
        frames, 'smoothstep', false
      ]
    )
  }

  strobe (
    sprite, scaleFactor = 1.3, startMagnitude = 10, endMagnitude = 20,
    frames = 10, yoyo = true, delayBeforeRepeat = 0
  ) {
    const bounce = `bounce ${startMagnitude} ${endMagnitude}`

    // Add `scaleX` and `scaleY` properties to Pixi sprites
    this._addScaleProperties(sprite)

    return this.makeTween(
      // Create the scaleX tween
      [
        sprite, 'scaleX', sprite.scaleX, scaleFactor, frames,
        bounce, yoyo, delayBeforeRepeat
      ],

      // Create the scaleY tween
      [
        sprite, 'scaleY', sprite.scaleY, scaleFactor, frames,
        bounce, yoyo, delayBeforeRepeat
      ]
    )
  }

  wobble (
    sprite,
    scaleFactorX = 1.2,
    scaleFactorY = 1.2,
    frames = 10,
    xStartMagnitude = 10,
    xEndMagnitude = 10,
    yStartMagnitude = -10,
    yEndMagnitude = -10,
    friction = 0.98,
    yoyo = true,
    delayBeforeRepeat = 0
  ) {
    const bounceX = `bounce ${xStartMagnitude} ${xEndMagnitude}`
    const bounceY = `bounce ${yStartMagnitude} ${yEndMagnitude}`

    // Add `scaleX` and `scaleY` properties to Pixi sprites
    this._addScaleProperties(sprite)

    const o = this.makeTween(
      // Create the scaleX tween
      [
        sprite, 'scaleX', sprite.scaleX, scaleFactorX, frames,
        bounceX, yoyo, delayBeforeRepeat
      ],

      // Create the scaleY tween
      [
        sprite, 'scaleY', sprite.scaleY, scaleFactorY, frames,
        bounceY, yoyo, delayBeforeRepeat
      ]
    )

    // Add some friction to the `endValue` at the end of each tween
    o.tweens.forEach(tween => {
      tween.onComplete = () => {
        // Add friction if the `endValue` is greater than 1
        if (tween.endValue > 1) {
          tween.endValue *= friction

          // Set the `endValue` to 1 when the effect is finished and
          // remove the tween from the global `tweens` array
          if (tween.endValue <= 1) {
            tween.endValue = 1
            this.removeTween(tween)
          }
        }
      }
    })

    return o
  }

  // 3. Motion path tweens

  followCurve (
    sprite,
    pointsArray,
    totalFrames,
    type = 'smoothstep',
    yoyo = false,
    delayBeforeRepeat = 0
  ) {
    return this.addTween(new PathTween(...arguments))
  }

  walkPath (
    sprite, // The sprite
    originalPathArray, // A 2D array of waypoints
    totalFrames = 300, // The duration, in frames
    type = 'smoothstep', // The easing type
    loop = false, // Should the animation loop?
    yoyo = false, // Shoud the direction reverse?
    delayBetweenSections = 0 // Delay, in milliseconds, between sections
  ) {
    // Clone the path array so that any possible references to sprite
    // properties are converted into ordinary numbers
    const pathArray = cloneDeep(originalPathArray)

    // Figure out the duration, in frames, of each path section by
    // dividing the `totalFrames` by the length of the `pathArray`
    const frames = totalFrames / pathArray.length

    // Set the current point to 0, which will be the first waypoint
    const currentPoint = 0

    // The `makePath` function creates a single tween between two points and
    // then schedules the next path to be made after it
    const makePath = currentPoint => {
      // Use the `makeTween` function to tween the sprite's
      // x and y position
      let tween = this.makeTween(
        // Create the x axis tween between the first x value in the
        // current point and the x value in the following point
        [
          sprite,
          'x',
          pathArray[currentPoint][0],
          pathArray[currentPoint + 1][0],
          frames,
          type
        ],

        // Create the y axis tween in the same way
        [
          sprite,
          'y',
          pathArray[currentPoint][1],
          pathArray[currentPoint + 1][1],
          frames,
          type
        ]
      )

      // When the tween is complete, advance the `currentPoint` by one.
      // Add an optional delay between path segments, and then make the
      // next connecting path
      tween.onComplete = () => {
        // Advance to the next point
        currentPoint += 1

        // If the sprite hasn't reached the end of the
        // path, tween the sprite to the next point
        if (currentPoint < pathArray.length - 1) {
          this.wait(delayBetweenSections).then(() => {
            tween = makePath(currentPoint)
          })
        }

        // If we've reached the end of the path, optionally
        // loop and yoyo it
        else {
          // Reverse the path if `loop` is `true`
          if (loop) {
            // Reverse the array if `yoyo` is `true`
            if (yoyo) pathArray.reverse()

            // Optionally wait before restarting
            this.wait(delayBetweenSections).then(() => {
              // Reset the `currentPoint` to 0 so that we can
              // restart at the first point
              currentPoint = 0

              // Set the sprite to the first point
              sprite.x = pathArray[0][0]
              sprite.y = pathArray[0][1]

              // Make the first new path
              tween = makePath(currentPoint)

              // ... and so it continues!
            })
          }
        }
      }

      // Return the path tween to the main function
      return tween
    }

    // Make the first path using the internal `makePath` function (below)
    const tween = makePath(currentPoint)

    // Pass the tween back to the main program
    return tween
  }

  walkCurve (
    sprite, // The sprite
    pathArray, // 2D array of Bezier curves
    totalFrames = 300, // The duration, in frames
    type = 'smoothstep', // The easing type
    loop = false, // Should the animation loop?
    yoyo = false, // Should the direction reverse?
    delayBeforeContinue = 0 // Delay, in milliseconds, between sections
  ) {
    // Divide the `totalFrames` into sections for each part of the path
    const frames = totalFrames / pathArray.length

    // Set the current curve to 0, which will be the first one
    const currentCurve = 0

    // The `makePath` function
    const makePath = currentCurve => {
      // Use the custom `followCurve` function to make
      // a sprite follow a curve
      let tween = this.followCurve(
        sprite,
        pathArray[currentCurve],
        frames,
        type
      )

      // When the tween is complete, advance the `currentCurve` by one.
      // Add an optional delay between path segments, and then make the
      // next path
      tween.onComplete = () => {
        currentCurve += 1
        if (currentCurve < pathArray.length) {
          this.wait(delayBeforeContinue).then(() => {
            tween = makePath(currentCurve)
          })
        }

        // If we've reached the end of the path, optionally
        // loop and reverse it
        else if (loop) {
          if (yoyo) {
            // Reverse order of the curves in the `pathArray`
            pathArray.reverse()

            // Reverse the order of the points in each curve
            pathArray.forEach(curveArray => curveArray.reverse())
          }

          // After an optional delay, reset the sprite to the
          // beginning of the path and make the next new path
          this.wait(delayBeforeContinue).then(() => {
            currentCurve = 0
            sprite.x = pathArray[0][0]
            sprite.y = pathArray[0][1]
            tween = makePath(currentCurve)
          })
        }
      }

      // Return the path tween to the main function
      return tween
    }

    // Make the first path
    const tween = makePath(currentCurve)

    // Pass the tween back to the main program
    return tween
  }

  // 4. Utilities

  /**
   * The `wait` method lets you set up a timed sequence of events.
   *
   * wait(1000)
   *   .then(() => console.log("One"))
   *   .then(() => wait(1000))
   *   .then(() => console.log("Two"))
   *   .then(() => wait(1000))
   *   .then(() => console.log("Three"))
   *
   * @param {number} [duration=0] how long to wait
   * @return {Promise}
   */
  wait (duration = 0) {
    return new Promise((resolve, reject) => {
      setTimeout(resolve, duration)
    })
  }

  /**
   * Adds a tween to this object.
   *
   * @param {BaseTween} tween the tween to add
   * @return {BaseTween} the tween that was added
   */
  addTween (tween) {
    this._tweens.push(tween)
    return tween
  }

  /**
   * A utility to remove tweens from the game.
   *
   * @param  {Tween} tween the tween to remove
   */
  removeTween (tween) {
    tween.pause()

    // array.splice(-1,1) will always remove last elemnt of array, so this
    // extra check prevents that (Thank you, MCumic10! https://github.com/kittykatattack/charm/issues/5)
    const index = this._tweens.indexOf(tween)
    if (index !== -1) {
      this._tweens.splice(index, 1)
    }
  }

  /**
   * Update all the tween objects in the `globalTweens` array.
   *
   * @param  {number} deltaTime the time passed in by the ticker
   */
  update (deltaTime) {
    this._tweens.forEach(tween => tween.update(deltaTime))
  }
}
